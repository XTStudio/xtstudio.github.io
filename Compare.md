# 对比其它框架

正如 Vue.js 文档所言，这个页面真的很难写，但却非常重要，可能你在使用其它跨平台框架的过程中，遇到了不少问题。你来这里的目的是看看 XT 是否有更好的解决方案。这也是我们在此想要回答的。

客观的来说，React Native 和 Weex 确实很好用，他们在前端开发者的生态系统中游鱼得水。然而，他们也存在着不少缺陷，并且，这些缺陷是由于设计上的问题而导致的。XT 尝试使用另外一种方式，避免这些缺陷。

## React Native

React Native 衍生于 React，React Native 有很多优点，例如：

* 强大的社区支持
* 易用的界面描述方式
* 与前端兼容的布局、样式设置方式
* 使用 Virtual DOM 进行脏刷新（减少与 UI 线程的通讯）

然而，React Native 确实在以下方面，存在一些问题，我们希望它能在往后的版本中，改进它们。

### 线程

无论是 iOS 或是 Android，React Native 会将 JavaScript 运行时分配到单独的线程中执行。这会导致一个致命的问题，异步！

由于所有的 JavaScript 操作都在子线程中执行，因此，当你需要更新某个视图属性的时候，它并不能立刻反映到 UI 上（因为 UI 线程与 JavaScript 线程不一致）。同样的，当你需要获取一个视图属性的时候，也不能获取到实时的值（React Native 在 JavaScript 端维护时一张巨大的表，把所需的属性完全 Copy 了一份）。

这在 UI 操作上，问题还不大，但在逻辑操作上，异步是最大的敌人。比如，React Native 就不能提供 Sync Storage API。

#### 改进：使用主线程运行 JavaScript

XT 与 React Native 不同的是，XT 将 JavaScript 线程运行于 UI 线程上。得益于此，XT 可以同步地、迅速地、无负担地与视图进行通讯。

### 布局性能

我们不能否认，React 真的很快，然而，这种快可能只适用于 PC。在移动设备上，使用 JavaScript 执行大规模的布局、排版运算，真的很卡！

然而，React Native 就真的这么做了！React Native 基于 React 开发，而 React 确实就是使用这种方式计算布局的。每一个视图的 frame 都会在 JavaScript 中经过计算后再返回至 UI 线程执行真正的布局。这里，会有疑问，既然计算过程是在子线程中执行，那应该不会卡顿。然而，事实是，JavaScript 是单线程模式的，JavaScript 不仅要做布局计算，还要做其它的事情。一旦 JavaScript 线程太忙了，来不及布局的时候，你的界面就乱套了！

#### 改进：开发者自行布局

XT 在布局上，倾向于原生方式。

在每一个视图大小变化时，使用回调的方式，通知视图类，让开发者自行使用代码更改子视图布局。这样做的好处在于，框架无须经过繁琐的重排即可知道视图的变化。代价是牺牲了易用性。

### 脏数据对比开销

> 部分文案来自：https://cn.vuejs.org/v2/guide/comparison.html

在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。

如要避免不必要的子组件的重渲染，你需要在所有可能的地方使用 ```PureComponent```，或是手动实现 ```shouldComponentUpdate``` 方法。同时你可能会需要使用不可变的数据结构来使得你的组件更容易被优化。

然而，使用 ```PureComponent``` 和 ```shouldComponentUpdate``` 时，需要保证该组件的整个子树的渲染输出都是由该组件的 props 所决定的。如果不符合这个情况，那么此类优化就会导致难以察觉的渲染结果不一致。这使得 React 中的组件优化伴随着相当的心智负担。

** 你可能会使用 Immutable.js 帮助你对比数据，然而，这是另外一个巨坑。 **

但是，手动实现 ```shouldComponentUpdate``` 方法以后就万事大吉了吗？不是的，在 React 应用运行的过程中，React 必须在每一帧中完整地递归整棵 Virtual DOM，逐个节点询问脏数据是否存在，这个开销对于 JavaScript 来说，实在是太重了。

#### 改进：开发者自行决定属性变更

在 XT 中，你可以获取到每个视图的实例，当你更改实例属性时，JavaScript 会同步地向 UI 发起变更需求。在这个过程中，没有 Virtual DOM，不需要任何遍历操作。

### API 设计

React Native 在 API 设计上，倾向于零散的、递进的、平台分离的思路。这将导致你无法在 iOS / Android 两个平台复用同样的代码。

#### 改进：一致的 API

XT 在 API 开发上，倾向于整套的、一致的设计思路，所有的 API 均可以在可支持平台上使用。

### 调试

React Native 的调试体验真是非常糟糕，但也是无可解决的。要在 React Native 中开启调试，你必须安装 Chrome 插件或是 VSCode 插件。调试的原理是在对应的调试器上执行 JavaScript 代码，然后将执行结果批量发送至手机上。调试器与手机通讯的机制是 WebSocket。

这会导致什么问题？

#### 异步

所有的操作，只能是异步的，因为 WebSocket 本身就设计为异步通讯。当你需要同步通讯的时候，怎么办？著名的 Realm 数据引擎使用的方法是，在手机上创建一个 HTTP 服务，使用 XMLHTTPRequest 同步通讯的方法实现。但是，这有多糟糕，只能让你自己去体验一下了。


#### 延迟

由于 JavaScript 运行时与 UI 线程需要通过 WebSocket 才能交换数据，整个界面、数据的更新都会大幅延迟。

#### 改进：在手机上运行调试器

XT 将调试器安置在手机上，使用 WebSocket 与 PC 调试器相连。不同的是，只有在需要的时候（Log / 断点 / REPL），才会交换数据。

### 规模

React Native 在设计之初就是以完整应用开发为目标的，你可以使用 React Native 开发一个应用（使用 cli 生成出来的工程就是一个应用），但是，你很难使用 React Native 开发一个模块。如果你真要这么做，你需要修改很多很多代码才能实现。

另外一点是，使用 React Native 编译出来的最终代码，文件大小也是相当可观的，里面附带了不少模板、兼容代码。

#### 改进：模块化设计

XT 在设计之初就是以模块化为目标的，XT 希望一个应用是以模块为中心，集合而成的。你可以使用 XT 开发一个模块，甚至只是一个 View 都是可以的。当然，你用 XT 开发一个应用，也没问题。

## Weex

Weex 当前仍然处于动荡期，暂时不宜下结论。